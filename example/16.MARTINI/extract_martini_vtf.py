#!/usr/bin/env python3

import sys, os
import numpy as np
import h5py
from datetime import datetime

# Get UPSIDE home directory
upside_path = os.environ['UPSIDE_HOME']
upside_utils_dir = os.path.expanduser(upside_path+"/py")
sys.path.insert(0, upside_utils_dir)

def write_vtf_frame(f, pos, frame_num):
    """Write a single frame in VTF format"""
    f.write("\ntimestep ordered\n")
    for i in range(len(pos)):
        x, y, z = pos[i]
        # Use coordinates as-is (already in Angstroms)
        f.write(f"{x:.3f} {y:.3f} {z:.3f}\n")

def write_pdb_frame(f, pos, frame_num):
    """Write a single frame in PDB format"""
    f.write(f"MODEL     {frame_num+1:4d}\n")
    for i in range(len(pos)):
        x, y, z = pos[i]
        # Use coordinates as-is (already in Angstroms)
        f.write(f"ATOM  {i+1:5d}  W   WAT A{i+1:4d}    {x:8.3f}{y:8.3f}{z:8.3f}  1.00  0.00\n")
    f.write("ENDMDL\n")

def main():
    if len(sys.argv) != 3:
        print("Usage: python extract_martini_vtf.py <input.up> <output.vtf/pdb>")
        sys.exit(1)

    input_file = sys.argv[1]
    output_file = sys.argv[2]
    output_format = output_file.split('.')[-1].lower()

    if output_format not in ['vtf', 'pdb']:
        print("Error: Output file must have .vtf or .pdb extension")
        sys.exit(1)

    # Open the HDF5 file
    with h5py.File(input_file, 'r') as t:
        # Get the number of frames
        n_frame = len(t['output/pos'])
        print(f"Number of frames: {n_frame}")
        
        # Get position data shape
        pos = t['output/pos'][0]
        n_particles = pos.shape[1]
        print(f"Number of particles: {n_particles}")
        print(f"Position data shape: {pos.shape}")
        
        # Print debug info for first frame
        print("\nFirst frame statistics:")
        print(f"Min position: {np.min(pos)}")
        print(f"Max position: {np.max(pos)}")
        print(f"Mean position: {np.mean(pos)}")
        print(f"Std position: {np.std(pos)}")
        
        # Read atom types from HDF5 input/type
        atom_types = t['input/type'][:].astype(str)
        martini_to_vtf = {'P4': 'W', 'Qd': 'NA', 'Qa': 'CL'}
        
        # Create output file
        with open(output_file, 'w') as f:
            if output_format == 'vtf':
                # Write VTF structure section with atom types and radii
                for i in range(n_particles):
                    mtype = atom_types[i]
                    vtf_name = martini_to_vtf.get(mtype, mtype)
                    f.write(f"atom {i} name {vtf_name} type {vtf_name} radius 2.0 resid {i} resname {vtf_name} segid s0\n")
            else:  # PDB format
                # Write PDB header
                f.write("TITLE     MARTINI WATER SIMULATION\n")
                f.write("REMARK    GENERATED BY UPSIDE\n")
                f.write(f"REMARK    DATE: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            
            # Write frames
            for frame in range(n_frame):
                pos = t['output/pos'][frame]
                
                # Reshape position data to (n_particles, 3)
                frame_pos = pos[0].reshape(n_particles, 3)
                
                # Check for NaN values and replace with last valid frame
                if np.isnan(frame_pos).any():
                    valid_pos = t['output/pos'][frame-1][0].reshape(n_particles, 3)
                    frame_pos = np.where(np.isnan(frame_pos), valid_pos, frame_pos)
                
                # Write frame in appropriate format
                if output_format == 'vtf':
                    write_vtf_frame(f, frame_pos, frame)
                else:  # PDB format
                    write_pdb_frame(f, frame_pos, frame)
                
                # Print progress every 100 frames
                if frame % 100 == 0:
                    print(f"Processed frame {frame}/{n_frame}")

if __name__ == "__main__":
    main() 